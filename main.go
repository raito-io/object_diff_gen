package main

import (
	"errors"
	"fmt"
	"go/types"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/hashicorp/go-multierror"
	cli "github.com/jawher/mow.cli"
	"golang.org/x/tools/go/packages"
)

var generatedTypes = map[string]string{}

func main() {
	app := cli.App("object_diff_gen", "Generate diff objects")
	chosenStruct := app.StringArg("STRUCTURE", "", "base structure to generate diff")
	chosenPackage := app.StringOpt("PKG", ".", "package")

	exitOnError := func(err error) {
		fmt.Println(err)
		os.Exit(1)
	}

	var err error
	app.Action = func() {
		err = parsePackage(chosenPackage, chosenStruct)
		if err != nil {
			exitOnError(err)
		}
	}

	err = app.Run(os.Args)
	if err != nil {
		exitOnError(err)
	}
}

func parsePackage(pkgName *string, structure *string) error {
	if pkgName == nil {
		return errors.New("no directory submitted")
	}

	if strings.TrimSpace(*pkgName) == "" {
		return errors.New("empty directory submitted")
	}

	pkg, err := loadPackage(*pkgName)
	if err != nil {
		return fmt.Errorf("generate %s: %w", *pkgName, err)
	}

	obj := pkg.Types.Scope().Lookup(*structure)
	if obj == nil {
		return fmt.Errorf("%s not found in package %s", pkgName, structure)
	}

	if _, ok := obj.(*types.TypeName); !ok {
		return fmt.Errorf("%s is not a named type", structure)
	}

	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		return fmt.Errorf("%s is not a struct", structure)
	}

	err = generate(pkg, *structure, structType)
	if err != nil {
		return fmt.Errorf("generate %s: %w", *structure, err)
	}

	return nil
}

func generate(pkg *packages.Package, sourceTypeName string, structType *types.Struct) error {
	f := jen.NewFilePathName(pkg.PkgPath, pkg.Name)

	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	_, err := generateStruct(structType, sourceTypeName, f)
	if err != nil {
		return fmt.Errorf("generate: %w", err)
	}

	// Build the target file name
	targetFilename := strings.ToLower(sourceTypeName) + "_gen.go"

	return f.Save(targetFilename)

}

func generateStruct(structType *types.Struct, name string, f *jen.File) (string, error) {
	if genName, found := generatedTypes[name]; found {
		return genName, nil
	}

	var changeSetFields []jen.Code

	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)

		code := jen.Id(field.Name())

		err := generateForType(field.Type(), code, f)
		if err != nil {
			return "", err
		}

		changeSetFields = append(changeSetFields, code)
	}

	genName := fmt.Sprintf("%sChangeSet", name)

	f.Type().Id(genName).Struct(changeSetFields...)
	generatedTypes[name] = genName

	return genName, nil
}

func generateForType(obj types.Type, code *jen.Statement, f *jen.File) error {
	switch v := obj.(type) {
	case *types.Basic:
		code.Op("*").Id(v.String())
		return nil
	case *types.Pointer:
		return generateForType(v.Elem(), code, f)
	case *types.Named:
		underlyingStruct := v.Underlying().(*types.Struct)

		typeName, err := generateStruct(underlyingStruct, v.Obj().Name(), f)
		if err != nil {
			return err
		}

		code.Op("*").Id(typeName)
		return nil
	case *types.Array:
		return generateForArrayType(v.Elem(), code, f)
	case *types.Slice:
		return generateForArrayType(v.Elem(), code, f)
	}

	return fmt.Errorf("type not handled: %T", obj)
}

func generateForArrayType(obj types.Type, code *jen.Statement, f *jen.File) error {
	switch v := obj.(type) {
	case *types.Basic:
		code.Op("*").Qual("github.com/raito-io/object_diff_gen/global", "ArrayDiff").Types(jen.Id(v.String()))
		return nil
	case *types.Pointer:
		return generateForArrayType(v.Elem(), code, f)
	case *types.Named:
		underlyingStruct := v.Underlying().(*types.Struct)

		typeName, err := generateStruct(underlyingStruct, v.Obj().Name(), f)
		if err != nil {
			return err
		}

		obj := v.Obj()

		code.Op("*").Qual("github.com/raito-io/object_diff_gen/global", "ArrayObjectDiff").Types(jen.Qual(obj.Pkg().Path(), obj.Name()), jen.Id(typeName))
		return nil
	case *types.Array, *types.Slice:
		code.Op("*").Qual("github.com/raito-io/object_diff_gen/global", "ArrayDiff").Types(jen.Id(v.String()))
		return nil
	}

	return fmt.Errorf("type not handled: %T", obj)
}

func loadPackage(path string) (*packages.Package, error) {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports | packages.NeedFiles | packages.NeedName, Tests: false}

	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		return nil, fmt.Errorf("loading package: %w", err)
	}

	var pkgErrors error
	for _, pkg := range pkgs {
		if len(pkg.Errors) > 0 {
			pkgErrors = multierror.Append(pkgErrors, fmt.Errorf("package %s contains %d errors: %v", pkg.Name, len(pkg.Errors), pkg.Errors))
		}
	}

	if pkgErrors != nil {
		return nil, fmt.Errorf("loading package: %w", pkgErrors)
	}

	return pkgs[0], nil
}
